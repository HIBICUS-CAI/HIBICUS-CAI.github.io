---
layout: default
title: About My Render System Lib
---

## レンダリングシステムライブラリーについて

>異なるスタイルのレンダリングをサポートできる柔軟性を持って、Windowsプラットフォームでのリアルタイムレンダリングライブラリー

このライブラリーは、レンダリングパイプラインを容易に構築できるため開発したものであります。

コンテンツは主に以下の通り分けられています :

- パイプラインシステム
  - パイプライン Pipeline（複数のトピックより組み立てる）
  - トピック Topic（複数のパスより組み立てる）
  - パス Pass（特定のDraw・Dispatchを行うオブジェクト）
- ほかのサブシステム
  - DirectXデバイス管理
  - カメラ作成・管理
  - 光源作成・管理
  - パーティクル作成・管理
  - Mesh作成・読み込み・管理
  - DrawCall管理
  - リソース管理
  - 静的リソース参照

レンダリングシステムライブラリーは、サブシステムにサポートされて、**異なるトピックより柔軟なレンダリングパイプラインを構築**、その中に必要なパイプラインで描画するという仕組みです。

例えば、[HycFrame3D](hycframe3d_jp.md)より作ったゲーム[JADEITE](jadeite_jp.md)の描画パイプラインは以下の順で、複数のトピックより構築されています :

`Diffuse+Normal+Position+Material+Depth Topic` → `SSAO Topic` → `Shadow Map Topic` → `Deferred Rendering Topic` → `Skybox Topic` → `Bloom Topic` → `Particle Topic` → `UI Topic`

## パイプラインシステム

- **Pipeline** どうやって一つのフレームを描画するの最高単位
- **Topic** ある効果を得るため一連の処理
- **Pass** 一つの処理がどう動作するを指示する、描画の最小単位

私の理解より、リアルタイム（特にゲーム）のレンダリングは、同一のデータ異なる手段で色々なテクスチャに変換して、最後これらのテクスチャを併合し、最終バッファーに書き込むという流れです。

そしてそういう「異なる手段」を柔軟に実行・追加・削除・編集できるため、私は一回の描画を一つのパイプラインの実行に、異なる手段をそれぞれのトピックにまとめました。

最後は使いたいPipelineを実行して、その中の全てのTopicが自動的に実行されます。

例えば影を描画するためShadow Mapを作りたいなら、以下のように処理を行うとすぐ実現できます。

1. `RSPass_Base`を継承して奥行きだけ描画する`RSPass_ShadowMap`クラスを作成する
2. `RSPass_ShadowMap`を確保する
3. 新しい`RSTopic`を作成、名を`shadow-topic`にして、さき確保した`RSPass_ShadowMap`のオブジェクトをこのTopicに追加し、実行順を設定する
4. `shadow-topic`を入れたいPipelineに追加、実行順を設定する

もし間違いがないなら、Pipelineを実行するとちゃんと動けるはずです。

図に言う主に以下のように :

![RSLib Pipeline Model](../../assets/rslib_pipeline_model.png)

## ほかのサブシステム

## 自分なりに頑張ったところ

優位性 :
- 柔軟な組み立て方

  こういう柔軟性は複雑なTopicで特に役立っています。例えば、パーティカルのシミュレーションを行いたい場合、Emit、Simulate、Tile Render、BlendをそれぞれのPassにすると、描画仕方が見やすいしデバッグも問題を早く特定できると思います。もしぐちゃぐちゃに組み立てば、他の人がコード読むと戸惑うし、もしバッグがあればどっちが原因も分かりづらいでしょう。

- マルチスレッドに適性がいい

  DirectX11のマルチスレッドは、主にCPU側のコード実行速度を上げるための機能と考えています。そして処理をPassやTopicに分けると、コードの実行はほぼ平均に分けられるので、並行性を上げられます。実際、このライブラリーのデフォルト設定は、Topicを単位にマルチスレッドで駆動しています。

## 改善すべきところ